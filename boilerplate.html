<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>Your deck.js Presentation</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" media="screen" href="extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="extensions/scale/deck.scale.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/style/mnml.css">

  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/transition/horizontal-slide.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="core/print.css">

  <!-- Required Modernizr file -->
  <script src="modernizr.custom.js"></script>
</head>
<body>
  <div class="deck-container">

    <!-- Begin slides. Just make elements with a class of slide. -->

    <section class="slide">
      <h1>Play! : présentation rapide</h1>
      <p>Play! est le framework web asynchrone/non-blocant de l'ombrelle Typesafe</p>
      <p></p>
    </section>

      <section class="slide">
          <h1>Play! : Anatomie d'un contrôleur</h1>
          <pre><code>
object MyController {

  def myAction(param1: String) = Action.async(parse.json) {
    request =>
      // first do something with the request

      // then perhaps do something of interest

      // finally return a Future[Result]
      Future.successful(Ok("Done"))
  }
}
          </code></pre>
          <p class="slide">Une action = une fonction dont les paramètres sont les paremètres de query</p>
          <p class="slide">L'action est construite au moyen d'un <code>ActionBuilder</code> ...</p>
          <p class="slide">... auquel on passe un <code>BodyParser</code> ...</p>
          <p class="slide">... et un fonction anonyme <code>Request => Future[Result]</code></p>
      </section>

      <section class="slide">
          <h1>Manipuler un body en JSON</h1>
          <p>On peut valider automatiquement un body JSON et le transformer en une case class</p>
          <p>Pour cela il faut une instance de <code>Reads</code> pour notre classe dans le scope implicit</p>
          <p>Le résultat de la validation sera soit</p>
          <ul>
              <li>Un <code>JsSuccess</code> contenant une instance de notre classe</li>
              <li>Un <code>JsError</code> contenant la liste des erreurs de validation détectées</li>
          </ul>

      </section>

    <section class="slide">
      <h1>Le problème</h1>
      <p>On va s'intéresser à un cas d'étude très simple mais qui présente quelques problèmes d'implémentation.</p>
      <p class="slide">On veut créer une API REST pour permettre à des utilisateurs de gérer leur activité sur les réseaux sociaux.</p>
      <p class="slide">On a :</p>
      <ul>
        <li class="slide">Un userService qui nous renvoie un user en fonction de son ID</li>
        <li class="slide">Un socialService qui permet d'updater le statut d'un user</li>
        <li class="slide">Un model StatusChange qui représente un requête de changement de statut</li>
      </ul>
      <p class="slide">On va écrire une action qui permet à un utilisateur d'updater son statut.</p>
    </section>

    <section class="slide">
      <h1>Les services</h1>
      <pre><code>
trait UserService {
  def findById(userId: String) : Future[Option[User]]
  // snip ...
}
trait SocialService {
  def updateStatus(credentials: Credentials, statusUpdate: StatusUpdate) : Future[Either[SocialError, StatusUpdate]]
  // snip ...
}
      </code></pre>
        <p>En bons programmeurs, on encode les effets de bord dans le typesystem.</p>
    </section>

    <section class="slide">
      <h1>Première mouture "Map party"</h1>
      <pre><code>
def updateStatus(userId: String) = Action.async(parse.json) {
  request =&gt;
    request.body.validate[StatusChange] match {
      case JsSuccess(statusUpdate) =&gt;
        <span class="example-current">userService.findById(userId)</span>.map{
          _.map{
            user =>
              <span class="example-next">socialService.updateStatus(user.credentials, statusChange)</span>.map{
                _.fold(
                  error =&gt; Forbidden,
                  success =&gt; NoContent
                )
              }
          }.getOrElse(NotFound)
      case JsError(error) =&gt; Future.successful(BadRequest(JsError.toFlatJson(error)),
  }
}
      </code></pre>
      <p>Cette action extrèmement simple pose une série de problèmes</p>
      <ul>
        <li>Le traitment des erreurs est loin du code qui génère l'erreur</li>
        <li>Les appels de service sont noyés dans le boilerplate</li>
        <li>Le code ne compile pas</li>
      </ul>
    </section>
    <section class="slide">
      <h1>Première mouture 1/2 "La cage aux folds"</h1>
      <pre><code>
def updateStatus(userId: String) = Action.async(parse.json) {
  request =&gt;
    request.body.validate[StatusChange].fold(
      error => Future.successful(BadRequest(JsError.toFlatJson(error)),
      statusUpdate =&gt;
        <span class="example-current">userService.findById(userId)</span>.map{
          mayBeUser =&gt;
            maybeUser.fold(NotFound)(
              <span class="example-next">socialService.updateStatus(user.credentials, statusChange)</span>.map{
                _.fold(
                  error =&gt; Forbidden,
                  success =&gt; NoContent
                )
              }
            )
        }
}
      </code></pre>
      <p>Il reste encore des problèmes</p>
      <ul>
        <li>Les appels de service sont (toujours) noyés dans le boilerplate</li>
        <li>Le code ne compile (toujours) pas</li>
      </ul>
    </section>

    <section class="slide">
      <h1>Ce qu'on aimerait bien</h1>
      <ul>
        <li>Une action sans boilerplate</li>
        <li>Avec les cas d'erreur gérés le plus tôt possible</li>
      </ul>
    </section>

    <section class="slide">
      <h1>C'est quoi le boilerplate ?</h1>
      <p>Définition en creux :</p>
      <p>Le rôle d'un controlleur c'est de </p>
      <ul>
        <li>Analyser la requête</li>
        <li>Appeler des services</li>
        <li>Construire la réponse</li>
      </ul>
      <p>Chaque ligne d'une action doit dont correspondre à une (et une seule) de ces activités </p>
      <p>... on constate qu'on en est assez loin</p>
    </section>


    <section class="slide">
      <h1>La structure du problème</h1>
      <img src="???" alt="dessin1">
      <p>Ce traitement paraît furieusement séquentiel</p>
    </section>

      <section class="slide">
          <img src="???" alt="Monads"/>
      </section>

      <section class="slide">
          <h1>Mandatory I-know-monads moment</h1>
          <p>Définissons l'idée de monade (dans la joie)</p>
          <ul>
              <li class="slide">Les monades forment un monoïde dans la catégorie des endo-foncteurs <span class="slide">LOL</span></li>
              <li class="slide">Une monade c'est un foncteur muni d'un <code>unit</code> et d'un <code>bind</code></li>
              <li class="slide">Une monade c'est un foncteur applicatif muni d'un <code>join</code></li>
              <li class="slide">Une monade c'est un machin qu'on peut mettre dans une for-comprehension</li>
          </ul>
      </section>


      <section class="slide">
          <h1>Ce qui serait bien ...</h1>
          <p>Ce serait de pouvoir exprimer chaque action avec juste une for-comprehension</p>
          <pre><code>
def updateStatus(userId: String) = Action.async(parse.json) {
  request =>
    for {
      maybeUser <- userService.find(userId)
      user <- maybeUser
      statusUpdateOrError <- request.body.parse[StatusUpdate]
      statusUpdate <- statusUpdateOrError
      _ <- socialService.updateStatus(user.credentials, statusUpdate)
    } yield NoContent
}
          </code></pre>
          <p class="slide">... bon, là ça compile pas, mais c'est normal</p>
          <p class="slide">La première ligne du for "fixe" la monade pour toute la for-comprehension</p>
          <p class="slide">Pour atteindre notre objectif, il nous faut donc un moyen d'emballer nos traitments dans <strong>la même monade</strong></p>
          <p class="slide">Par ailleurs, on n'a pas de moyen de capturer les cas d'erreur pour renvoyer un résultat pertinent</p>
      </section>



      <section class="slide">
          <h1>ScalaZ à la rescousse !</h1>
          <p>Scalaz fournit des implémentations du concept de monad transformer</p>
          <p>Un monad transformer combine les effets de deux monades dans une nouvelle monade</p>
          <p>Donc il nous faut "juste" trouver la bonne combinaison</p>
      </section>

      <section class="slide">
          <h1>Sidenote : \/</h1>

          <p>Le type scala.util.Either n'est pas monadique</p>

          <p>Pour avoir un Either (ou sum type) monadique, il faut "choisir" un "côté"</p>

          <p>C'est exactement ce que fait le type \/ de scalaz (on prononce Disjonction)</p>

          <p>\/ a la même forme qu'Either, mais il est "right-biased"</p>

          <p>càd : dans une for-comprehension sur \/ le traitement continue tant que résultat est \/-</p>

      </section>

      <section class="slide">
          <h1>À la recherche de notre monad transformer</h1>
          <img src="???" alt="Dessin1bis"/>
          <p>Pour être uniforme il nous faudrait à chaque étage</p>
          <ul>
              <li>Une Future</li>
              <li>Un \/</li>
          </ul>
          <p>Le type que l'on cherche est donc <code>EitherT[Future, Result, Result]</code></p>
      </section>

      <section class="slide">
          <h1>Le bout du tunnel</h1>
          <pre><code>
def updateStatus(userId: String) = Action.async(parse.json) {
  request =>
    val result = for {
      statusUpdate <- EitherT(Future.successful(request.body.validate[StatusUpdate].fold(
              err => BadRequest(JsError.toFlatJson(err)).left,
              su => su.right
            )))
      user <- EitherT(userService.find(userId).map(u => u \/> NotFound))
      _ <- EitherT(socialService.updateStatus(user.credentials, statusUpdate).map{
              fe =>
                fe.fold(err => Forbidden.left, identity)
            })
    } yield NoContent

    result.run.merge
}
          </code></pre>
          <p>Enfin du code qui compile !</p>
          <p>Mais c'est encore un peu verbeux/illisible</p>
          <p>La bonne nouvelle, c'est qu'on peut généraliser/abstraire la transformation de nos résultats intermédiaires en EitherT</p>
      </section>

      <section class="slide">
          <h1>Notre mini DSL</h1>
          <pre><code>
object ActionDSL {
  type Step[A] = EitherT[Future, Result, A]

  def fromJsResult[A](onError: JsError => Result)(in: JsResult[A]): Step[A] = EitherT(
    Future.successful(in.fold(
      e => onError(e).left,
      s => s.right
    )
  )

  def fromFuture[A](onFailure: Throwable => Result)(in: Future[A]): Step[A] = EitherT(
    in.map(_.right)
      .recover(\/.left compose onFailure)
  )

  def fromFOption(onNone: => Result)(in: Future[Option[A]): Step[A] = EitherT(
    in.map(a => a \/> onNone)
  )

  def fromFEither[A, B](onLeft: B => Result)(in: Future[B \/ A]): Step[A] = EitherT(
    in.map(_.leftMap(onLeft))
  )


  def fromJsResult[A](onError: JsError => Result)(in: JsResult[A]): Step[A] = EitherT(
     Future.successful(in.fold(
       e => onError(e).left,
       s => s.right
     ))
  )

  def fromBoolean(onFalse: => Result)(in: => Boolean): Step[Boolean] = EitherT(
    if(in) Future.successful(true.right)
    else Future.successful(
  )
}
          </code></pre>

      </section>

      <section class="slide">
          <h1>AcionDSL</h1>
          <p>Le DSL est extrèmement simple, il se contente de définir comment on transforme chaque type en <code>EitherT[Future, Result, A]</code></p>
          <pre><code>
def updateStatus(userId: String) = Action.async(parse.json) {
  request =>
    val eitherT = for {
      statusUpdate <- request.body.validate[StatusUpdate]                        |> ActionDSL.fromJsResult(err => BadRequest(JsError.toFlatJson(err))
      user         <- userService.findById(userId)                               |> ActionDSL.fromFOption(NotFound)
      _            <- socialService.updateStatus(user.credentials, statusUpdate) |> ActionDSL.fromFEither(Forbidden)
    } yield NoContent

    eitherT.run.map(_.toEither.merge)
}
          </code></pre>
          <p class="slide">C'est mieux, mais il reste un tout petit peu de cérémonie</p>
          <p class="slide">Il faut écrire le même <code>eitherT.run...</code> pour chaque action</p>
          <p calss="slide">Le choix de la méthode d'<code>ActionDSL</code> pourrait être automatique</p>
      </section>

      <section class="slide">
          <h1>MonadicAction</h1>
          <p></p>
      </section>

      <section class="slide">
          <h1>Conversions implicites</h1>
      </section>
      <section class="slide">
          <h1>Version Finale</h1>
          <pre><code>
def updateStatus(userId: String) = Action.async(parse.json) {
  request =>
    for {
      statusUpdate <- request.body.validate[StatusUpdate]                        ?| (err => BadRequest(JsError.toFlatJson(err))
      user         <- userService.find(userId)                                   ?| NotFound
      _            <- socialService.updateStatus(user.credentials, statusUpdate) ?| Forbidden
    } yield NoContent
}
          </code></pre>
      </section>
    <!-- End slides. -->

    <!-- Begin extension snippets. Add or remove as needed. -->

    <!-- deck.navigation snippet -->
    <div aria-role="navigation">
      <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
      <a href="#" class="deck-next-link" title="Next">&#8594;</a>
    </div>

    <!-- deck.status snippet -->
    <p class="deck-status" aria-role="status">
      <span class="deck-status-current"></span>
      /
      <span class="deck-status-total"></span>
    </p>

    <!-- deck.goto snippet -->
    <form action="." method="get" class="goto-form">
      <label for="goto-slide">Go to slide:</label>
      <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
      <datalist id="goto-datalist"></datalist>
      <input type="submit" value="Go">
    </form>

    <!-- End extension snippets. -->
  </div>

<!-- Required JS files. -->
<script src="jquery.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
  $(function() {
    $.deck('.slide');
  });
</script>
</body>
</html>
